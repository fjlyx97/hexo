---
title: 设计模式记录笔记
date: 2020-07-30 16:32:10
tags:
- 学习
- 设计模式
categories : "设计模式"
---

> - 设计模式之美笔记
> - 基于极客时间专栏

<!-- more-->

# 常见的设计模式
## 创建型
单例模式、工厂模式（工厂方法，抽象工厂）、建造者模式
- 不常用：原型模式

## 结构型
代理模式、桥接模式、装饰者模式、适配器模式
- 不常用：门面模式、组合模式、享元模式

## 行为型
观察者模式，模板模式，策略模式，责任链模式，迭代器模式，状态模式
- 不常用：访问者模式，备忘录模式，命令模式，解释器模式，中介模式

# 里式原则
继承关系中，子类涉及要保证在替换父类时，不改变原有程序逻辑，不破坏原有程序的正确性

# 单例模式
目前大部分的单例模式，都是属于进程唯一的单例模式。

## 线程唯一
通过HashMap存储对象，Key是线程ID，Value是对象。Java当中存在ThreadLoacl，可以直接实现线程唯一单例。

## 集群唯一
将单例对象，序列化后存储到外部存储区（比如文件）。进程在读取这个单例模式的时候，从外部文件读取到内存，并反序列化成对象，然后在使用。用完后还要在存储为外部共享存储区。（需要用到分布式锁）

# 工厂模式
## DI容器
DI容器事先不知道应用会创建哪些对象，需要维护一个配置，来保存创建对象的必要信息。

# 建造者模式（Builder模式、生成器模式、构造者模式）
## 为什么要建造者模式
平时开发，使用New关键字调用类的构造函数就可以创建对象。但会出现以下几个问题:
1. 构造函数的参数很多，容易搞错顺序
2. 配置项拥有一定的依赖关系，比如设置了（maxTotal,maxIdle,minIdle）中的一个，就必须设置另外两个参数。并且还需要一定的约束条件
3. 希望对象是不可变对象，对象创建好之后，就不能再修改内部的属性值

建造者模式就是为了解决这些问题。先创建建造者，再通过set方法设置建造者的值，再通过build()方法创建对象之前，做集中的校验，并且把构造函数修改为私有全校，这样就只能通过建造者来创建对象了。

- 实际上，如果不关心对象是否有短暂的无效状态，也不在意对象是否是可变的，就没必要用建造者模式

## 和工厂模式有何区别
工厂模式是用来创建不同，但是类型相关的对象。建造者是创建同一种类型的复杂对象。

# 原型模式（很少单独使用）
如果对象创建成本较大，而同一个类的不同对象之间差别不大，在这种情况下，我们利用原有对象（原型）进行复制（拷贝)的方式创建新对象，以达到节省创建时间的目的，这种现象被称为原型模式。

实际上，对象**申请内存，给成员变量赋值**，不会花费太多时间，对于大部分业务系统来说，是可以忽略的。但是如果对象中的数据要经过复杂计算才能得到，或从RPC、网络、数据库、文件系统等慢速IO读取，这时候原型模式才能发挥出作用。

# 代理、桥接、装饰器、适配器四种设计模式的区别
这四种模式都是比较常用的结构型设计模式，代码结构非常相似。但是他们的用意完全不同。
- 代理模式：不改变原始接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能（和装饰器的最大区别）
- 桥接模式: 将接口部分和实现部分分离，从而使他们较为容易，相对独立的改变
- 装饰器模式： 在不改变原始接口的情况下，对原始类增强，并支持多个装饰器嵌套使用
- 适配器模式： 事后补救策略，提供和原始类不同的接口。而代理模式、装饰器模式提供和原始类相同的接口

# 门面模式
实际开发时，尽量保证接口的可复用情况，但是针对特殊情况，可以提供冗余的门面接口，来提供更易用的接口。