---
title: C++学习记录
date: 2018-03-05 16:22:08
tags:
- 编程
- 学习
- C家族
categories : "C家族"
---

> - 学校课程新增C++
> - 记录易错知识点以及易忘知识点
> - 大坑待填

<!--more-->

1. cout有控制符，如转换进制的如下：
```cpp
cout << hex << ;
hex 十六进制
oct 八进制
dec 十进制
```

2. const 与 #define 不同，它拥有存储单元，有地址，指针可指向它。建议取代define.

3. const在指针的不同位置：
```cpp
const char* name = "chen"; //当const位于类型前面的时候，内容不允许改变，指针指向的地址可以改变。
name[3] = 'o'; //不允许
name = "hello"; //允许

char* const name = "chen"; //当const位于类型后面的时候，代表常指针，指针所指向的地址不允许改变。
name[3] = 'o'; //允许
name = "hello"; //不允许
```

4. const常用于操作数组时，不改变数组内容。

5. 函数省略类型时，默认为int。

6. inline内联函数定义必须在头文件中实现。

7. 函数指定默认值的参数必须放在最右侧，以便达到一一对应。

8. 函数重载以参数个数及其类型判断，即可以参数个数相同，类型不同。返回值类型不参与判断！！！

9. 可以使用::访问全局变量，如下：
```cpp
int x;
int main()
{
    int x;
    cout << ::x;
}
```

10. union可以有多个成员，但是只能使用一个成员变量。

11. 使用new进行分配空间时，需要提供所有维大小。（待定）

12. 引用必须初始化，可以作为返回值。

13. 不允许建立void类型的引用，不能建立引用的数组。

14. 引用不是一种数据类型，指针是。所以没有引用的引用，也没有引用的指针。

15. 结构体成员变量默认为public，而类默认为private。

16. C++推荐在类外定义函数，如果在类内定义函数，则默认为inline内联函数。

17. 在类声明中，不允许对数据成员赋值。

18. 类在实例化对象时，不允许加括号，如下
```cpp
CPeople xiaoming(); //不允许，这代表实例化一个CPeople的函数
CPeople* xiaohong = new CPeople(); //允许，并且推荐这种写法。
```

19. 构造函数是没有返回值，哪怕是void。

20. const对象以及引用对象，必须在构造函数的初始化列表中进行初始化。

21. 数据成员是按照类中声明顺序进行初始化，而与初始化中的列表无关。（重要）

22. 析构函数不允许被重载。

23. 类数组，如果只有一个成员数据，可以使用大括号进行初始化。如果两个参数，可以如下：
```cpp
CPeople pep[3] = { CPeople(1,2) , CPeople(2,3) , CPeople(3,4) };
```

24. 在写一个函数的时候，尽量为其完善构造函数，拷贝构造，析构函数。

25. 使用拷贝构造时，默认使用浅拷贝，如果遇到指针在里面，需要注意指针，使用深拷贝。即构造函数参数为：const& 类名。

26. 调用拷贝构造有三种情况。
```cpp
1.一个类初始化另一个类
2.函数的参数是类的对象
3.函数的返回值是类的对象
```

27. 一个类多个对象数据共享，需要使用静态成员。

28. 静态成员应在类外初始化，并且在定义对象前就必须初始化完毕。不允许被初始化列表初始化（重要）

29. 静态成员函数主要用于访问静态数据成员。并且如果是private，则不能被外部访问。

30. 静态成员函数没有this指针，并且只能通过对象名来访问静态成员。（重要）

31. 类外定义友元函数，可以不必加上类名，只需保证参数相同。友元函数必须通过入口参数传递进对象名。

32. 友元关系是单项的，不具备交换性。

33. 子类调用构造函数时，如果父类也有构造函数，需要在子类构造函数初始化列表中为父类初始化。

34. 如果将一个对象申明为常对象(类名 const 名字)，则不能调用该对象的非const的成员函数，否则报错。常成员函数例子如下：void print() const;

35. 常成员函数只能用于类中，并且可以和同名非常函数进行重载。

36. 继承如果不指定类型，默认以private继承。

37. 子类可以继承父类的private成员，但是需要父类提供的public函数才能访问。

38. 如果一个函数的参数为int& ，则它不可以传入类似i*3这样的变量。如果这样做了，在内部可以近似认为生成了一个const int& temp@ = i\*3。所以如果参数为const int&，则可以传入不报错。

39. static在c++和c中有细微的差别，如果在C中加上static代表只能在本文件中访问。

40. 在运算符重载当中，如果运算符右边为整数，则会尝试调用重载函数参数中类的构造函数。（重要，可以使用构造函数将数字转换成类对象）

41. 继承当中，如果父类成员是private，不管使用哪一种继承限定词，子类都是无法直接访问父类成员。

42. C++推荐使用int(a)这种方式进行强制转换，而不是使用(int)a，进行强制转换，前者更像调用一个函数。

43. explicit在构造函数之前添加，可以告诉编译器这就是一个构造函数，不能用来强制转换。

44. operator 目标类型() ，可以用来指定数据类型转换为类的对象

45. 构造函数首先调用基类，然后是类对象成员，最后是派生类的构造函数体。

46. 父类指针可以指向子类，但是只能访问子类从父类继承而来的成员。

47. 虚函数必须是成员函数，不能是友元函数或者是静态成员函数。因为需要特定的对象才能激活虚函数。

48. 输入输出流拥有各种成员函数：
```cpp
cout.put() //输出字符，可以是ASCII码
cin.get()   //读取一个字符
cin.getline() //读取一行
cin.ignore(n,终止字符)  //跳过n个字符读取，可以只含一个参数
//....
```

49. 流成员函数进行格式控制：
```cpp
setf(flags) //设置格式
unsetf(flags) //取消格式
width(n) //指定宽度
fill(ch) //填充字符
precision(n) //设置小数精度
```

50. 数组作为函数参数时候，如果使用sizeof计算其大小，会得到指针的大小。

51. 在VC6.0的时候，输入输出流返回必须是引用，因为ostream和istream对象是不可复制的。

52. 函数调用选择顺序如下：非模板函数，显式具体化，模板函数。显式具体化的例子:
```cpp
include <iostream>
using namespace std;
template<typename T>
void swaper(T& a , T& b)
{
    T temp = a;
    a = b;
    b= temp;
    return;
}

template<> void swaper<double>(double&a , double& b)
{
    cout << a + b << endl;//调用
}
int main()
{
    double a = 10 , b = 20;
    swaper(a,b);    //显式具体化后，调用的其实是cout<< a+b;
    cout << a << " " << b;
    system("pause");
    return 0;
}
```

53. const修饰的成员函数可以改变static的变量，因为static变量储存在静态区而不属于类。

54. 使用string类，如果使用<或>比较符，是从左往右比较，与字符长度大小无关

55. 拷贝构造时，基类会被调用，需要自己在初始化列表中调用

56. 引用不允许指向不同的对象，独一无二。

57. 对象在基类构造函数执行之前不会成为一个真正的对象（成品）

58. 析构函数一旦开始执行，所有成员变量便成为未确定的值

59. namespace和classes不同，namespace可以跨越多个文件，但是classes不行

60. 在类当中，子类是无法赋值给父类，反之可以

61. c++实现多态引用同样可以实现

62. 一旦继承中出现虚基类，以后继承皆为虚基类（待定）

63. ostream对象不允许拷贝构造，即返回值必须为ostream&

64. operator++为前置运算符，operator++(int)为后置运算符
```cpp
//example
class Base;
Base Base::operator++(int)
{
    Base t(*this);
    this->num++;
    return t;
}
```

65. 缺省构造函数即代表没有参数列表的构造函数，一旦手动定义带参数的构造函数，编译器则不会帮我们生成缺省的构造函数