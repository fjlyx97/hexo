---
title: Go语言核心36讲
date: 2020-05-23 23:23:05
tags:
- 编程
- 学习
- golang家族
categories : "golang家族"
---

> - 深入理解Golang
> - 基于极客时间专栏，记录学习笔记

<!--more-->

# 从一道面试题开始
- 你知道设置GOPATH有什么意义吗

设置GOPATH，可以近似看成Go语言的工作目录，它是一个工作路径，也可以是多个目录路径。

# Go语言源码的组织方式
Go语言源码以代码包为基本组织单位，在文件文件系统来看，就是以**目录**一一对应。一个代码包包含多个.go扩展名的文件，并且这些文件需要被声明为同一个package。

一般来收，生成的可执行文件和源码目录同名，否则以package为准。

# 构建和安装Go程序的过程
构建使用：go build，安装使用：go install。两个命令都会执行编译、打包等操作。
- 如果构架的是库源码文件（无main），操作结果会被存在临时目录当中，因此这个主要是为了检查和验证
- 如果构建的是命令源码文件，结果文件则会被储存到**源码文件**所在目录当中

# 命令源码文件
package为**main**，并且包含一个**无参数**、**无返回值**的main函数，如下：
```go
package main
func main() {
    fmt.Println("Hello")
}
```

对于一个独立的程序来说，命令源码文件只能有一个

# 库源码文件
库源码文件可以被看成不能被直接运行的源码文件，但是可以被其他程序进行import

# 变量重定义现象
如果假设，两个变量都在一个大的语句块当中，并且名字一样，类型一样。子语句块会屏蔽掉父语句块（类型必须一样）。但是如果类型不一样，或者语句块不嵌套的话，则会报redeclared，比如import . "../path"，如果变量名冲突，就会报错。

# 判断一个变量的类型
通过使用类型断言，如下：
```
var a int = 10
value , ok := interface{}a.(int)
```

- ok代表的是判断结果，true或者false。如果是true的话，value则为转化后的结果。

# 转换所带来的问题
如果从32为转8位会造成精度丢失的问题，float也一样。如果写下string(-1)的代码，会发现无法找到对应的unicode字符，因此显示为�，可以注意排查。

string转byte的话，假设string存储的是你好，转为[]byte的话，长度为6，因为一个中文占三个字节

# type申明类型
如果使用:type myInt int的话，myInt和int其实是两种不同的类型。而如果加上等号如：type myInt = int，则两者是同一种类型。
```
type myInt = int
func (m myInt)Say() {
	
}
//会提示错误如：Cannot define new methods on non-local type 'builtin.int'
```

# 字段的KEY不能是哪些类型
官方文档中记载：Go语言字典的KEY不能是函数，字典，切片类型，但是interface{}同样也不行

语言规范中规定，KEY必须可以施加操作符==或者！=，意味着必须支持判等操作。因此KEY同样不能为interfae，或者会触发panic

如果只申明一个字典：var t map[string]int，它的值为nil类型，但是这时候去读是不会发生任何错误的。直到触发写操作，产生panic

# 非法竞态访问检测
竞态访问代表没有在任何同步操作下，并行读取同一份数据：如多个协程同时运行，有的协程在读，有的协程在复制数据，就会出现竞态访问。

- 使用go run -race 文件名，来进行竞态检测
- 也可使用go build -race来生成文件，手动运行触发竞态检测

# channel通道
使用通道的值本身就是并发安全的，也是Go语言自带，唯一满足并发安全性的类型

- 基本原则：不要从接收端关闭通道

## 通道发送和接收有哪些基本的特性
1. 同一个通道，发送操作是互斥的，接收操作也一样
2. 发送和接收操作，对元素值的处理不可分割（保证并发安全，绝对不会出现只复制一半的情况）
3. 发送操作在**完全完成**之前会被阻塞，接收操作同样也是如此

接收操作通常包含：复制通道内的元素值，放置到接收方，删掉原值。这就意味着使用通道，元素的值一定会被**复制一份**


## 错误操作
对于值为nil的通道，无论它的具体类型是什么，都会永久属于阻塞状态。这就意味着，通道的零值是**nil**，必须要使用make进行初始化

1. 对于已经初始化，但是未关闭的通道，收发操作一定不会引发panic，但是通道一旦关闭后，发操作就会引发panic.
2. 重复关闭一个通道也会引发panic。**接收操作可以感知到通道关闭**。

## 传slice和array
array是值类型，因此如果传入通道，会被复制一份，并且，修改值不会影响到之前的数组。而slice是引用类型，可以影响到之前的数组。

## 单向通道的应用价值
约束作用，这种一般会出现在接口声明中的某个方法定义上。
```go
type Notifier interface {
    SendInt(ch chan<- int) //约束这个接口，必须要发送数据，不允许接收
}
```

## select语句和通道联用，注意事项
select的选项，没有顺序之分，是随机的。且每次只有一个分支的代码会被执行。

select的分支分为两种：候选分支和默认分支（default），且转为通道设计，因此只能接通道。

select中进行break，只会退出select而不会退出for

## 引申的思考题
### 如果在select语句中发现某个通道已关闭，那么应该怎样屏蔽掉它所在的分支？
可以重新make一个通道，长度为0，这样这个case就会一直阻塞
```go
for {
    select {
        case _ , ok <- ch1:
            if !ok {
                ch1 = make(chan int)
            }
        ...
    }
}
```

### 在select语句与for语句联用时，怎样直接退出外层的for语句？
结合goto语句，后者结合break loop语句

# 一等公民：函数
在Go当中，函数是一等公民（可以变为普通的值，赋予变量，在函数间传递）

# 接口变量什么时候才为真正的nil
如果接口变量没有被赋值的话，那么它的值就是nil，如果被赋值了，哪怕赋值对象是nil，接口变量也不会是nil。Go语言会用runtime.iface去包装他，底层是两个指针，一个指向类型信息，一个指向动态值，这时候动态值是nil，但是类型信息不是。

# 通过unsafe.Pointer操纵可寻址的值
作为开发者，请谨慎使用，unsafe.Pointer转换到值之后，可以通过unsafe.Offsetof（成员变量名），进行地址偏移，达到修改指定成员变量的值

# for range的坑
1. range表达式只会再for语句开始执行时被求值一次，无论后面会有多少次迭代。
2. range表达式的求值结果会被复制，修改不会影响原值

# 互斥锁
sync.Mutex属于值类型，如果在函数当中进行传递，则会复制一把新的锁，对新锁的操作不会影响到以前的锁

# sync.Pool对象的生命周期
- gc会清除sync.pool缓存的对象
- 对象的缓存有效期为下一次GC之前