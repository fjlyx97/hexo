---
title: 刷题记录
date: 2021-01-30 13:41:08
tags:
- 编程
- 学习
- 算法
categories : "数据结构和算法"
---

> - 刷题记录
> - 记录常见的题型，以及易错的知识点

<!--more-->

# 二分法
## 防止死循环
- 循环的终止条件为:start + 1 < end
- 最后判断结果的时候，需要start和end都判断
```
// 找到第一个大于等于target的数的下标
while (start + 1 < end) {
    int mid = start + (end-start)/2 //防止溢出
    if (num[mid] >= target) {
        end = mid;
    } else {
        start = mid;
    }
}
return num[start] == target ? start : end;
```

## 常见题型
- lintcode.14.二分查找（first position of target) 入门题
- lintcode.74.第一个错误代码版本 入门题
- lintcode.159.寻找旋转排序数组中的最小值（和14类似，区分两种情况）入门题
- lintcode.585.山脉序列中的最大值 (判断mid和mid+1)
- lintcode.75.寻找峰值(判断mid,mid+1,mid-1)
- lintcode.62.搜索旋转排序数组(两次二分，第一次二分的时候，注意区分边界，起点不一定是start（0），重点不一定是end（len-1))

# 二叉树
碰到二叉树的问题，先想想整棵树上，该问题的结果，和左右子树的关系树什么

- 考虑当前节点的情况，左右字树是否有必要校验NULL的情况
- 非递归版本的前序和中序，必须要会写

## 普通二叉树常见题型
- lintcode.97.二叉树的最大深度 入门题
- lintcode.480.二叉树的所有路径(需要考虑只有一个点的特殊情况）入门题
- lintcode.596.最小子树(每个节点的目的，是返回自己的累加值)
- lintcode.93.平衡二叉树
- lintcode.597.具有最大平均数的子树
- lintcode.1311.二叉搜索树的最近公共祖先（方案一：维护一个队列，方案二：分治，假设出现了任意节点，就不用往下找了，要么p,q在同一侧，要么在不同侧）
- lintcode.578.二叉搜索树的最近公共祖先III（相比上一题，差别在于有可能节点不存在与树中）

## BST（二叉查找树）常见题型
- lintcode.95.验证二叉查找树（方案一：中序遍历，看是否从小到大。方案二：二分，记录左右子树的最大、最小值）

```
if (left && !right) {
    return left;
}
if (!left && right) {
    return right;
}
if (left && right) {
    return root;
}
if (!left && !right) {
    return NULL;
}
```

## 分层遍历
如果要分层遍历，需要记录上一层节点个数和当前层节点个数

# 双指针
对于两个变量如何组合的问题，可以循环其中一个变量，研究另一个变量如何变化

## 两数之和及变种题型
- lintcode.587.两数之和不同组成（同向双指针）
- lintcode.57.三数之和
```
注意去重！
哈希表： for循环a,b,去哈希表里面找-c
双指针： a+b+c=0 => a+b=-c for循环c（假设c每次都作为最小的数值） 校验重复c以及双指针
```
- lintcode.382|918.三角形计数 (假设a <= b <= c，枚举c，最小的两条边相加大于第三边，其他一定边相加一定满足)
- lintcode.609.两数和-小于或等于目标值
- lintcode.533.两数和的最接近值
- lintcode.59.最接近的三数之和

## 同向双指针常见题型
- lintcode.539.移动零（同向双指针，入门题）
- lintcode.100.删除排序数组中的重复数字（同向双指针，如果后面的指针不等于前面的指针，就赋值过来）
- lintcode.610.两数和-差等于目标值 (nums[r]-nums[l] ， r取第一个大于target的数字)
- nc.41.最长无重复字符字串（双指针，并用哈希表，存储之前存在的数字，如果发生重复，更新l为之前存在数字的下标+1（下标要小于l））

## 相向双指针
- lintcode.8.旋转字符串（先翻转全部，再根据offset翻转）

# 排序算法
## 归并排序
- 注意递归终止条件
- 传参的时候，区间为(l,mid),(mid+1,r)
- merge的时候，i = l , j = mid+1

# 字符转数字算法
需要考虑负数的情况

# 三步翻转法
翻转数组类似翻转字符串
1. 找到分界点
2. 反转全部
3. 在分界点的左右二次反转
```
[4,5,1,2,3] -> [1,2,3,4,5]
```
- lintcode.39.恢复旋转排序数组

如果翻转字符串的话，可以用空格分割。

# 旋转矩阵
两次二分，直接搜索到对应行
- lintcode.28.搜索二维矩阵I

从左下角开始，依次排除一行或者一列，如果相等，直接排除一行+一列
- lintcode.38.搜索二维矩阵II