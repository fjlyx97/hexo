---
title: 刷题记录
date: 2021-01-30 13:41:08
tags:
- 编程
- 学习
- 算法
categories : "数据结构和算法"
---

> - 刷题记录
> - 记录常见的题型，以及易错的知识点

<!--more-->

# 二分法
## 防止死循环
- 循环的终止条件为:start + 1 < end
- 最后判断结果的时候，需要start和end都判断
```
// 找到第一个大于等于target的数的下标
while (start + 1 < end) {
    int mid = start + (end-start)/2 //防止溢出
    if (num[mid] >= target) {
        end = mid;
    } else {
        start = mid;
    }
}
return num[start] == target ? start : end;
```

## 常见题型
- lintcode.14.二分查找（first position of target) 入门题
- lintcode.74.第一个错误代码版本 入门题
- lintcode.159.寻找旋转排序数组中的最小值（和14类似，区分两种情况）入门题
- lintcode.585.山脉序列中的最大值 (判断mid和mid+1)
- lintcode.75.寻找峰值(判断mid,mid+1,mid-1)
- lintcode.62.搜索旋转排序数组(两次二分，第一次二分的时候，注意区分边界，起点不一定是start（0），重点不一定是end（len-1))

# 二叉树
碰到二叉树的问题，先想想整棵树上，该问题的结果，和左右子树的关系树什么

- 考虑当前节点的情况，左右字树是否有必要校验NULL的情况

## 常见题型
- lintcode.97.二叉树的最大深度 入门题
- lintcode.480.二叉树的所有路径(需要考虑只有一个点的特殊情况）入门题
- lintcode.596.最小子树(每个节点的目的，是返回自己的累加值)
- lintcode.93.平衡二叉树
- lintcode.597.具有最大平均数的子树
- lintcode.1311.二叉搜索树的最近公共祖先（方案一：维护一个队列，方案二：分治，假设出现了任意节点，就不用往下找了，要么p,q在同一侧，要么在不同侧）
```
if (left && !right) {
    return left;
}
if (!left && right) {
    return right;
}
if (left && right) {
    return root;
}
if (!left && !right) {
    return NULL;
}
```


# 排序算法
## 归并排序
- 注意递归终止条件
- 传参的时候，区间为(l,mid),(mid+1,r)
- merge的时候，i = l , j = mid+1

# 字符转数字算法
需要考虑负数的情况