---
title: redis
date: 2020-03-31 19:57:53
tags:
- linux
- 学习
- 数据库
categories : "数据库"
---

> - redis学习笔记
> - 主要记载redis使用、底层知识

<!--more-->

# 传统数据库data page
传统数据库的data page一般大小为4K，和底层磁盘一次读取4K相同。因此data page可以大于4K，但是小于4K，会造成磁盘读取4K数据的浪费
- 数据库索引在内存当中只存B+树（树干），而命中索引后，会读取对应的data page

# redis支持的类型
redis支持的字符串，散列，列表，集合，有序集合，这里指的是value支持，而不是key。而memcached的value则没有类型的概念。

# 基础help
基础help命令主要通过两个维度查询
```
help @类名
help 命令
```

# bitmap
在大批量数据时，可以通过bitmap来节省空间，如统计两千万用户在某一天是否存在登录，offset则为用户ID，或者是统计用户登录的区间，每一天以一个bit代替

## 布隆过滤器
使用bitmap有可能造成数据冲突，所以我们可以定义K个哈希函数，将一个KEY，多次哈希之后，再次映射到bitmap当中，这样可以保证，如果得到结果为不存在一定不会误判。但是会带来一个问题，假设这个数据不存在，但是被判断为了存在，从而造成数据丢失。
- 我们可以通过调整哈希函数的个数，位图大小，要存储的数字比例，可以将这种误判尽可能降到最低。

# list
list有序，但是针对的是插入有序，而非数据有序

# set和sorted_set
## set
set是无序的，且支持集合的交并差操作，允许随机抽取数据，如：SRANDMEMBER key [count]，后面的count如果是正数，则一定取出对应个数量的元素，且保证唯一，但是如果元素不够的话，则会返回整个集合的所有元素。后面的count如果是负数，则数据元素不保证唯一，取出即可。

## sorted_set
如何排序是一个问题，假设有苹果、香蕉、梨，他们可以通过含糖量，大小，价格，热度等等，即排序规则需要自己指定
- 如果排序的值都为1，则会按照名称字典序排序。
- 默认是从小到大排序（左小右大）
- 同样具备集合操作

### 跳跃表（skiplist）
跳跃表的查找类似于二分查找，但是如果多次插入数据，如果不更新上层索引，则会出现两个索引节点当中，存在的数据节点非常多。因此我们可以定义一个随机函数，来决定将这个节点插入到哪几级索引当中，比如随机函数生成了K，我们就将节点添加到第一级到第K级索引中。

# 管道
服务器会按顺序处理请求，因此可以一次性发送多个命令，使用管道传输，降低RTT开销
```
(printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379
```

# 发布订阅
SUBSCRIBE来监听一个频道，PUBLISH可以推送数据到一个频道。并且所有监听频道的客户端都可以收到数据。

# 事务
redis事务不像mysql那么完整，谁的命令exec先到达，就先执行谁的事务。因此没办法确定一个值是否一定可以正确获取。
- watch指令可以在开启事务前，进行监听key的value。如果开启事务后，监听的值被更改了，事务不会执行

# 模块
redis4.0之后加入了模块，因此可以导入第三方模块（如布隆过滤器）

## 布隆过滤器（redis4.0之后支持）
主要用于解决缓存穿透的问题，如果不存在，直接结束，不允许请求数据库
- [布隆过滤器](https://oss.redislabs.com/redisbloom/)

# LRU缓存
- 业务逻辑：key的有效期
- 业务运转：内存是有限的，随着访问的变化，应该淘汰冷数据
## 回收策略（摘自文档）
[lru-cache](http://redis.cn/topics/lru-cache.html)
- noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
- （常用）allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
- （常用）volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
- allkeys-random: 回收随机的键使得新添加的数据有空间存放。
- volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
- volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

## ttl时间
如果一个key设置了过期时间，读不会让时间变更，但是如果重新写，会造成时间丢失，即被重置