---
title: C语言学习笔记
date: 2017-10-04 18:53:13
tags:
- 编程
- 学习
- C家族
categories : "C家族"
---

> - 日常学习中难免遇到一些坑
> - 在此记录自己学习C语言时的笔记
> - 更新缓慢，大坑已填


<!--more-->

> - 已结课

1. 在早期的C89的标准中，必须在最开始的地方定义变量，不过现在的编译器没那么严格。（VC6.0碰到的坑）
2.  - %o代表八进制，八进制以0开头。
    - %x代表十六进制，十六进制以0x开头。
    - %p代表指针变量。
3. 变量最好在定义时就初始化，否则忘记赋值直接使用会出现特别大的奇怪数值。（刷OJ的时候碰到的坑）。
4. 单精度(float)七位有效数字，双精度(double)十六位有效数字。小数有六位，逗号算一位
5. 转义字符参见表格。
6. 大小写ASCII码相差32。
7. 一旦有实数参与运算，结果也为实数。否则大多数机器采取“向零取整”的策略。
8. scanf中，%*3d表示读取时跳过3列。
9. scanf中，若scanf("%d,%d"); 出现了逗号，则输入时也要出现逗号。
10. scanf中，若scanf("%d\n"); 出现了\n，则需要多输入一个任意字符。
11. i++是表达式，不能参与运算。 （书上例题）
12. 代码若需要换行，可以使用\来连接（连接符）。
13. else总是和它上面最近的if配对（就近原则）。
14. do-while结尾中的分号不能少。
15. 指针本质是变量，也拥有地址，二级指针就是用来存储指针地址，指针可以进行值传递。
```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    int a = 10;
    int *p = &a;
    int* *p1 = &p; //这里代表生成一个二级指针，指针也是有地址的
    int *p2 = p; //这个代表的是地址的传递，忽略了指针的地址的事实。
    system("pause");
    return 0;
}
```

16. 设p为指针，\*p++可以看作\*(p++)。
17. 设p为指针，num为数组名，p指向num。则p[3]==num[3]。
18. 指针和数组相差：指针可以参与运算，和数组名不可以。如p++成立而num++报错。
19. 2[p]是合法的，等同于\*(2+p)。
```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    int num[5] = {1,2,3,4,5};
    int *p = num; //在这里c只是普通指针，并不称为数组指针或者指针数组。
    printf("%d",*p++); //在这里是先执行p++，在执行*p.
                       //即*(p++)
    p[3] == num[3]; //这是成立的，指针的下标运算 , p[2] == p+2;
    
    int b = 4;
    int *p1 = &b;
    p1[2] = 13; //按道理说已经越界，但编译器未报错
    //数组名和指针变量 数组名不允许自加的，且不参与运算，而指针变量可以
    //数组名是一个常量 , 而 2[p] 是合法的 ,等同于 *(2+p)
    system("pause");
    return 0;
}
```
20. 数组地址和数组第一个元素的地址相同。
21. 数组中一旦一个元素被初始化，其他元素都会被初始化为0。但是如果没有初始化任一元素，则所有元素都是不确定的存在，使用风险很大。
22. int num[][3]是成立的，但是使用的同时一定要对它进行初始化，否则必将编译失败。
23. 有的时候我们可以使用int num[2][3] = {1,2,3,4,5,6};来初始化一个数组，编译器会将其按顺序分配到内存当中。
24. 数组在初始化的时候，不允许使用变量初始化，必须使用常量。(C99标准支持，偶然遇见,在此记录)
```c
int a = 10;
int num[a]; //这是错误写法，但是有的编译器可以编译通过
            //C不允许使用这种写法，但规则是人定的。
            //C++至今不允许使用，但有vector代替
//若是一定要动态分配的话
int n;
scanf("%d" , &n);
int* a = (int*)malloc(sizeof(int) * n);
int i = 0;
for (i = 0 ; i < n ; i++)
{
    scanf("%d",&a[i]);
}
free(a);
```
25. 数组之中不允许使用等号直接复制，数组名是常量，不允许在赋值运算符的左侧，可是使用循环赋值或memcpy赋值。
```c
#include <stdio.h>
#include <memory.h>
int main(void)
{
    int a[5] = {1,2,3,4,5};
    int b[5] = {a[4]}; //可以使用这种赋值方法，将a中的元素赋值给b
    //错误写法： b = a;
    //有两种常见赋值，一种是循环，一种是memcpy复制
    int i = 0;
    //循环赋值
    for (i = 0 ; i < 5; i++)
    {
        b[i] = a[i];
    }
    //memcpy赋值,包含在<memory.h>或<string.h>中 memcpy(要被赋值，要赋值，赋值大小);
    //内存拷贝，认地址不认元素
    memcpy(b,a,sizeof(int)*5);
    memcpy(&b[0],&a[0],sizeof(int)*5);
    return 0;


    //由此我们可以引申出，如果要从a[3]开始对b赋值的话
    memcpy(&b[0],&a[3],sizeof(int)*2);
}
```

26. 数组指针和指针数组是不同的概念
```c
#include <stdio.h>
int main(void)
{
    int num[5] = {1,2,3,4,5};
    int *p[5] = {&num[0],&num[1],&num[2],&num[3],&num[4]}; //指针数组，生成五个指针分别指向num中的元素。p先和[]结合。
    /*-------------------------------------------------------------*/
    //要生成一个指针指向数组，通过分解可以得到
    //*p1 代表指针
    //int[5]代表数组
    //实际理解是int[5] *p1; 但是编译器不允许通过
    //根据优先级int *p1[5]，会先和中括号结合，所以需要括号将p1括起来

    int (*p1)[5] = &num; //数组指针
    //生成一个指针，指向数组，在C语言中，数组名是第一个元素的地址，但是数组本身也存在地址。
    //元素个数一定要一样，否则就是不同类型
    
    //两者可以看成是运算符优先级的不同，[]的优先级大于*，但是()的优先级是最大的。

    return 0;
}
```

27. 如果用到了自定义函数，返回值需要注意，输出为float但使用返回值为int的函数，结果会很奇怪。（OJ碰到的大坑）

28. 如果碰到字符串切割或者拼接问题，printf输出时需要考虑\0，否则OJ报错。（OJ大坑）

29. 除法使用向零取整，所以当使用： 1 / 10的时候，得到的答案是0。（刷Oj遇到的方法）

30. 用到for循环的时候，需要注意到边界问题，否则有可能会超出时间限制。（刷oj遇到的超时问题）

31. 写for循环时，一旦不小心在末尾加上分号，则初始化的值可能出现极大的偏差。（舍友遇到的大坑）

32. 每个字符串末尾都需要加上\0,否则使用put或printf函数时，不会终止输出，出现乱码。（同学遇到的大坑，自己刷oj也碰到过）。

33. 自增或自减运算符不能用于常量表达式，如5++，(a+b)++ 。且方向自右向。

34. 转化时向高精度的方向转换，即int -> float -> double。

35. 字符串和数字相互转换的函数:
```c
//需要包含在头文件stdlib.h
atof(str) //返回double
atoi(str) //返回int
atol(str) //返回long
/*-------------------*/
itoa(num,str,radix) //radix是要求转换的进制数，int转str
ltoa(num,str,radix) //long转str
```

36. i \*= k+2 ，k+2为一个整体，即 i = i * (k + 2);

37. a > b > c ，从左往右比较，并用0,1替换比较结果，即如果a > b，会替换成： 1 > c。

38. 字符串和字符指针的区别，参考如下代码：
```c
#include <stdio.h>
int main(void)
{
    char str1[] = "Hello World";
    char *str2 = "Hello World";
    printf("%p\n","Hello World");
    printf("%p\n",str1);
    printf("%p\n",str2);
    /*这第一个和第三个结果是相同的。
     *第一个代表字符串地址
     *第三个代表生成一个指针指向字符串地址
     *而第二个代表新生成一片空间，与原先字符串的空间两者相独立，互不干扰，所以打印出的指针地址不同。
    */
    return 0;
}
```

39. 数组作为函数参数，如下代码：
```c
/*当数组作为参数传入时，是可以直接修改数组内容的
 *即数组首地址指针被传入到函数当中。
 */
#include <stdio.h>
void input(double score[]) //不需要输入元素个数
{
    //函数实现;
}
//亦或者使用如下写法
void show(double* score) //两者等同，有细微差别，涉及底层机制。
int main(void)
{
    double score[10];
    input(score);
    return 0;
}
```

40. - 八进制为0~7
    - 十进制为0~9
    - 十六进制为0~9,A~F，其中A为10，F为15

41. 声明一个负数，使用%u，即无符号整数打印
    - 先将该数绝对值以二进制的方式表达出来
    - 再将位数所有按位取反
    - 最后将得到的二进制加1
    - 逆推回十进制

42. 转义字符中，存在八进制和十六进制
    - \ddd 三位八进制    不能超过三位，且数字为0-7
    - \xhh 二位十六进制   不能超过两位

43. - 十进制转二进制，一般采用除2取余法，直到商为0，得到的余数从最尾巴倒着排回去
    - 转其他进制同样也可以采用除数取余法
    - 其他进制转十进制，可以将数字展开，一次乘以各个数字的次方
    - 二进制转八进制，从后往前，三位一组，不够用0补，然后以十进制方法转化，如(11001.101)<sub>2</sub>，其中001代表1，011代表3，所以这个数值就是31。
    - 同理八进制转二进制也可以直接将每一位展开
    - 二进制转十六进制，以四位为一段，如（11111101）<sub>2</sub>，从1111得出F，1101得出D，所以值是FD。

44. 关于自增自减运算符的深入剖析（参考网络上的资料）
    - 在不同编译器中，这个结果可能出现不同。
    ```c
    int i = 3;
    int j = 4;
    int a = i++ + i++;
    int b = ++j + ++j;
    printf("%d, %d\n", a, b);
    /**
     *这个答案在VC6.0里面为6，12
     *但是在vs2017里面测试确为7，12
     *以以上的例子来说
     *i++的理解应该是执行完整个表达式的其他操作后，然后才自增
     *++j的理解为先自增再参与其他运算
     */
    ```
    - 再看另一组代码
    ```c
    int i = 3;
    int j = 4;
    int a = i++ + i++ + i++;
    int b = ++j + ++j + ++j;
    printf("%d, %d\n", a, b);
    /**
     *这组结果为9，19
     *vs2017中为12，19
     *按上一组的理解，这一组应该为21
     *但是这一组存在两个同级+运算
     *根据+的左结合性，式子可看成(++j + ++j) + ++j;
     *即 (6 + 6) + 7;
     */
    ```
    - 最后一组代码
    ```c
    int i=1;
    int j=1;
    int a = i++ + i++ + i++ + i++ + i++ + i++ + i++; // 七个
    int b = ++j + ++j + ++j + ++j + ++j + ++j + ++j;
    printf("%d, %d\n", a, b);
    printf("%d, %d\n", i, j); 
    /**
     *a = 1 + 1 + 1 + 1 + 1 + 1 + 1 = 7
     *b = 3 + 3 + 4 + 5 + 6 + 7 + 8 = 36
     *总的来说，后置++比较好看出来，前置++需要注意运算符的优先级
     *如果非应试教育，应当尽量不使用这种式子，造成误解
     */
     ```

45. 当碰到：a += a *= a -= a *= 3这类式子时，应从右往左一次计算，如下：
    ```c
    a *= 3;
    a = a - a;
    //......
    //此后不再叙述
    ```

46. 使用extern声明全局变量的时候，可以扩大变量的作用域。如在其他文件中存在一个整形变量a，在本文件中可以使用extern int a来申明全局变量，类型名可写可不写，如使用extern a

47. 使用static声明全局变量时，只能用于本文件，即便在其他文件中使用了extern这个关键字，也无法调用，那一行只能调用一次，不可重复调用，所以声明时最好就一同初始化，static 函数也同理

48. 找到字符串结束符
```c
    #include <stdio.h>
    int main(void)
    {
        char *str = "hello world";
        int i = 0;
        while (str[i] != '\0')
        {
            i++;
        }
        return 0;
    }
```

49. 注释不允许嵌套（练习大坑）

50. ++允许使用在float上面，但是%必须是两个整型

51. - 原码：符号位加上真值的绝对值，即第一位是符号，其余位为值。符号位1代表符号，0代表正号
    - 反码：整数的反码是本身。负数是在原码的基础上，符号位不变，其他位取反
    - 补码：正数的补码是本身。负数的补码是在原码的基础上，符号位不变，其他位取反，最后+1。（即反码+1）

52. 在使用&&进行判断时，如果前面为假，则代表短路，不再执行后面的语句。（习题大坑）

53. 逻辑与运算符优先级大于逻辑或

54. 逻辑运算问题，查看如下代码：
```c
#include <stdio.h>
int main(void)
{
    int  a = 1;
    int  b = 1;
    int  c = 1;
 
    ++a || ++b && ++c;
 
    printf("a = %d , b = %d, c = %d\n", a, b, c);
    return 0;
}
```
- 运算符高是表示: ++a || (++b && ++c)，但是运算顺序依旧从左往右
- 举四则运算的例子：
- 1 + (2 \* 3)
- 而不是 ( 1 + 2 ) \* 3
- 但他们是从左往右运算，即就从+而言，它先算1
- 所以回归问题，先演算++a，于是||出现短路

55. 函数允许返回一个指针，例如
```c
int * getaddress(int x)
{
    return &x;
}
```

56. 函数名即为地址，所以有函数指针这个说法，具体实现如下：
```c
int max(int x,int y)
{
    if ( x >= y)
    {
        return x;
    }
    else
    {
        return y;
    }
}
int main(void)
{
    int a , b ,c;
    int (*p)(int , int);
    p = max; //代表p指向max
    scanf("%d %d", &a, &b);
    c = (*p)(a,b);
    printf("\n a = %d , b = %d , max = %d",a,b,c);

    return 0;
}
```
- int (\*函数指针)(参数列表);
- 对指向函数的指针变量，进行运算，如p++,p--是毫无意义的事情

57. 结构体类型定义的时候并不分配内存空间，只有申明变量的时候才分配内存。

58. 结构体里面允许嵌套结构体，使用.（成员运算符）来逐级访问。

59. 共用体的大小取决于最长成员所占用的存储空间，而结构体则是所有成员之和。如下例子
```c
union data
{
    int a;
    float b;
    double c;
    char d;
}obj;
//这个data所占的空间为double所占的8字节。、
```

60. 不能同时引用两个或两个以上的共用体成员，否则出错。

61. 枚举序号默认从0开始排列，但是也可以初始化，不允许后面复制。 

62. 异或的独特用法
- 四种定义：
- 0 ^ 0 = 0
- 0 ^ 1 = 1
- 1 ^ 0 = 0
- 1 ^ 1 = 1
- 来看如下示例：
```c
//交换律
a ^ b = b ^ a
//结合律
( a ^ b ) ^ c = a ^ ( b ^ c ) 
//逆运算
( a ^ b ) ^ b = a; //这个可以用来判断：假设一堆数组里面其他数字出现两次，找出只出现一次的那一个。
```

63. 使用左移运算符<<，例如3 << 3 为3乘2的三次方，(3 << 3) - 1 为3乘以2的三次方减一

64. signed char的范围是-128-127，超过之后可能变成负数，OJ题目留意（OJ题目碰到的坑）

65. cin同样遇到空格也会停止，需要留意一下字符串问题。

66. 十六进制不区分大小写

67. 形式参数是局部变量

68. register保存在CPU寄存器当中，用以加快程序运行，常用于频繁使用的变量之上。

69. 对未赋初值的静态局部变量，C编译程序将自动给予初值为0

70. 当使用头文件时候，要防止重定义
```c
#ifndef _H_
#define _H_
//Your Code
#endif
```

# 大坑待填