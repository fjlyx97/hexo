---
title: Go进阶训练营笔记
date: 2020-12-07 21:30:00
tags:
- linux
- 学习
categories : "golang家族"
---

> - 业务碰到安全规范
> - 记录安全攻防基础技能

<!-- more-->

# 安全原则
CIA原则，机密性、完整性、可用性。评估安全水平的时候，分别从这三个范围进行考量

## 机密性
明确授权规则，明确每一项数据可以被什么样的主题访问。

针对机密性的攻击，有破解加机密算法，逆向混淆的代码，但是技术不断提高。更多的时候，我们面临的是人为原因导致的疏忽。

## 完整性
确保数据只被授权的主体，进行授权修改。

## 可用性
可用性是确保数据能够被授权的主体访问到，简单来说，就是“可读”。

# 安全原则黄金法则
主要包含三个部分：认证、授权、审计，其实就是描述一个生命周期：先登录、在进行操作、最后留下记录

1. 可信的身份认证是建立安全保障的第一步
2. 身份认证完后，下一步就需要明确权限的大小。
3. 完成操作后，安全需要检查做了什么（审计），当发现异常操作时，留下证据。

# 密码学记录
在使用对称加密算法的时候，需要通信双方定一个密钥，但是协商过程中密钥存在泄漏的可能性。非对称加密就是用来解决这个问题的

# 单点登录
单点登录（SSO Single Sign On)，用户一次认证，访问所有的网页。

## CAS
Cas（集中式认证服务），开源的单点登陆框架，提供了一套完整的落地方案。

## JWT
非常轻量级单点登陆流程，在客户端保存一个凭证信息，每次登陆带上这个凭证，作为登陆状态的依据。JWT好处在于，不需要应用服务端去额外维护cookie或者session。

## OAuth
主要特点是授权，通常用QQ、微信登陆其他应用采用的协议。通过OAuth，用户在完成认证中心的登陆后，应用只能够验证用户确实在第三方登陆了，但应用的登陆态还是要自己维护。

## 建议
多花功夫去接入成熟的单点登陆体系，而不是自己实现一个简化版的。JWT应用最广，如果只想对用户信息做统一管理，选它。如果认证中心用来维护账号密码，由业务去维护用户所绑定的其他手机等信息，采用OAuth。

# XSS攻击
在网页中，给定异常输入，插入一段恶意的JavaScript脚本，就可以窃取隐私信息，或者仿冒操作。这就是Xss攻击

## 反射型XSS
主要位于前后端一体的系统，后端读取到参数后，直接拼接返回给前端，这时候如果出现异常输入
```
<h3><script>alert('xss')</script></h3>
```

浏览器就会解析出js语句，不过目前有的浏览器已经提供了一定XSS保护功能

## 基于DOM的XSS
原理和反射型XSS差不多，只不过HTML是通过Javascript操作Dom树，来实现这个功能，只不过不经过服务端了而已（纯前端，自己读取，自己执行）

## 持久性XSS（存储型XSS）
相比以上两种，危害更大。恶意的脚本被存储到了数据库中，只要浏览了网页，就会执行。

## XSS攻击的危害
1. 窃取Cookie
2. 未授权的操作
3. 按键记录和钓鱼

## XSS防护
核型原则：一切用户输入不可信，验证输入OR验证输出，检测和过滤用户输入

- 检测中，更推荐白名单原则，比如输入分数的地方，只有整形变量合法。

CSP防护：XSS通常会收到长度限制，因此黑客通常无法提交完整的js代码，所以会引入外域。可以通过在Http Header添加一个Content-Security-Policy选项，定义白名单域名，限制非白名单资源访问

# SQL注入
## 修改Where语句
登陆操作使用SQL拼接:
```
sql = `select * from users where username = "' + uName +'" and password = "' + uPassword'"
```

如果黑客选择输入: " or ""=""，那么语句恒为真，数据库将返回全部数据，这就是所谓的万能密码


## 执行任意语句
利用分号进行分割，则可以执行任意语句

## 危险
1. 绕过验证
2. 任意篡改数据
3. 窃取数据
4. 消耗资源（While死循环操作）

## 解决方案
1. 合理使用PreparedStatement，可以解决99.99%的sql注入问题。
2. 使用存储过程，思想类似PreparedStatement
3. 验证输入

# CSRF/SSRF攻击
浏览器通常会在登陆后，在Cookie中存储一些必要的身份信息，黑客可以利用这一点，编写恶意的JavaScript脚本，窃取网页信息，对用户是无感知的，这就是（跨站请求伪造）

假设有接口：
```
地址：http://pay.com/pay_money
方法：post
接口参数： to , amount
```

黑客可以编写如下网页:
```html
<html>
    <body>
        <form action="http://pay.com/pay_money" method="POST">
            <input type="hidden" name="to" value="hacker">
            <input type="hidden" name="amount" value="1111.01">
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```
由于input带有hidden属性，对用户来说是不可见的

- 只要接口配置有问题，就能被csrf利用，黑客只需要在自己域名中，搭建一个诱导性的网页，任何用户都可以收到csrf攻击，用户根本没办法防止。

## CSRF防护
业界标准的方法，是用CSRFToken来防护。
### CSRFToken
1. 用户请求界面
2. 返回界面，并且携带CSRF Token
3. 用户请求转账接口，并携带CSRF Token

### 二次验证
当验证后，再弹出一个窗口进行二次验证

### 只使用JsonApi
Json ajax限制跨域

### 验证Http refer字段
浏览器有可能有漏洞，不一定完全安全

## SSRF
CSRF是针对用户浏览器，SSRF是针对服务器，服务器有请求代理的功能，如果黑客伪造内网的URL请求，则有可能暴露危险数据

带来的危害：
1. 内网探测
2. 文件读取

### 防护
- 白名单限制永远是最简单的，最高效的防护措施
- 对资源类型限制，只允许HTTP,HTTPS
- 尽量使用POST，避免GET，并且做好校验

# Linux安全
考虑Linux安全时，不需要过多的考虑内核安全，而是应该考虑用户层安全。内核安全留给官方补丁。

## Linux的认证机制
Linux有两个比较关键的文件：/etc/passwd和/etc/shadow。

- /etc/passwd是全局可读，不具备保密性，因此不会直接存储密码，用x来占位，实际的密码存储到/etc/shadow中，仅Root可读

/etc/shadow保存了加密后的密码，密码有效天数，失效多少天后告警等信息，可以通过**change**mingling ,强制某用户在多少天内，必须对密码进行修改。

- 可以使用John the Ripper，使用已知的弱密码库，对Linux的弱密码进行检测

## 授权机制
| 权限 | 文件 | 目录｜
| ---- | ----| ----|
| 读 | 可以读取文件内容 | 可以读取目录列表 |
| 写 | 可以修改文件内容 | 可以修改目录列表（新建、删除、重命名） |
| 执行 | 运行文件 | 进入目录（CD到目录） |

nobody通常具有整个操作系统的最小权限，当登陆Linux，首先获得的就是Nobody身份，再从Nobody登陆到其他正常用户身份上。

## 审计机制
系统日志主要分为三类：用户登录日志、特殊事件日志、进程日志

- 用户登录日志主要在/var/log/wtmp和/var/run/utmp，本身是二进制文件，但是可以通过who/users/ac/last/lastlog这样的命令获取
- 特殊事件日志，主要包括/var/log/secure和/var/log/message

# Redis安全
## 认证
- Redis性能很高，能够以每秒几十万次的速度猜测密码，因此必须设置一个足够强的密码。（推荐32位数字加字母）
- Redis按测试，设置了密码，性能会降低20左右，需要取舍

## 授权
Redis本身不提供授权机制，但是我们可以通过重命名简介提供这个功能
```
rename-command CONFIG asdlkfjsaldkfjkls
```

## 审计
redis只提供了日志打印，加密需要客户端自己实现

# Mysql安全
相比Redis，Mysql是一个比较成熟的数据库工具，自身的安全性就很高，所以通过正确的配置Mysql的安全选项，我们就能获得较高的安全保障

# 防火墙
黑客在网络攻击时，第一步会扫描系统对外开放的端口，尝试发起连接或者攻击

## 包过滤防火墙
工作在网络层或者传输层上，这两个层级，网络请求都是以TCP或者UDP数据包的形式进行流动的。大部分路由器，甚至Linux应用（Iptables）也具备类似的功能。
- 通常情况下，不需要额外购买设备，配置路由器即可。
- 功能较弱

## 应用网关防火墙
工作在应用层，可以看成是代理。接收客户端发出的请求，然后以客户端的身份请求服务端。
- 防火墙可以获得系统和应用的全部信息，从而实现更复杂的功能。

## 状态检测防火墙
包过滤防火墙的升级。区别在于，会以连接的形式看待TCP和UDP的包
- HTTP三次握手，包过滤防火墙看到三个包，状态检测防火墙只能看到一个包

目前市面上普遍使用，性能更优秀（不会去解析HTTP请求的内容）

## 防御盲区
只防御网络边界，如果突破了，后续的请求将穿透防护。

不一定所有的请求都经过防火墙，比如通过物理网线接入服务器。

# WAF（Web应用防护系统）
应用网关防火墙的一种，只专注Web安全的防御
## 透明模式
对HTTP流量透传，HTTPS流量解密的话，需要和服务端同步HTTPS对称密钥。
- 容易部署，缺点是无法提供认证服务

## 反向代理
和透传不一样的是，服务端的连接，其实是WAF发起的，可以提供认证服务，功能丰富
- 缺点是功能丰富意味着开销更大，对硬件要求更高。

## 插件模式
WAF不再是独立的安全产品，而是以插件的形式，依附Web服务端。常用的技术就是AOP（切面编程技术）
- 缺点是依附服务端，对服务端性能造成影响，升级流程需要服务端同步评估

# IDS(入侵检测系统)
两种类型：NIDS（网络入侵检测系统），HIDS（基于主机型入侵检测系统）

## NIDS
NIDS主要检测流量中的攻击行为，一般部署在内网（路由器、交换机）

## HIDS
检测服务器系统中的攻击行为。NIDS运行在某个网络节点上，相当于集中式的对网络流量进行检测。HIDS运行在每个服务器中，相当于分布式检测，每个服务器只关注自己内部的行为。

- 一般用Root运行，可以监控执行的系统命令，发起和接受网络请求，运行的进程、监听的端口号等

## IPS
对NIDS和HIDS加入防御系统，就成了NIPS，HIPS，统称IPS(入侵防御系统)，IDS强调检测，IPS强调拦截

# 蜜罐
部署在内网的服务器，没有任何保护戳事，提供带有漏洞的服务，吸引黑客攻击他。

## 低交互式蜜罐
所有服务都是模拟的，不提供真实的服务功能。比如模拟22端口，只要有连接，都返回成功，但是无法真正连接

## 高交互式蜜罐
提供真实的服务，并不限制，用来做详细的记录

## 优缺点
### 优点
- 几乎不会误报
- 真实的攻击行为，数据量小，价值高
- 不需要已知攻击样本，甚至可以发现新的攻击方式

### 缺点
- 运气，不一定发现蜜罐
- 实现复杂

# RASP
从应用底层防护，如Java Agent，但是编程语言不一定都支持