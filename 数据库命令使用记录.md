---
title: 数据库命令使用记录
date: 2020-03-13 09:27:42
tags:
- linux
- 学习
- 数据库
categories : "数据库"
---

> - 牛客网数据库刷题
> - 记录一些常用易迷惑的知识点

<!--more-->

# distinct
distinct是对所有列都起作用，因此必须放在最开头，如下语句是错误的：
```sql
SELECT country, distinct province from person; // 该语句是错误的
```

# limit
limit m,n代表从m开始，显示n条,m最低为0

# join
- 直接使用inner join并配上on，则为取符合条件的两个表的交集
- left join为左表+两表交集
- right join为右表+两表交集
- full join 为左表列+右表列，直接相加即可

# where和having
```sql
select addtime,name from dw_users where addtime> 1500000000
select addtime,name from dw_users having addtime> 1500000000
```
第一条没问题，第二条报错，where可以通过数据库直接筛选，having需要从select中出现的字段筛选

- 因此having可以和group by配合使用而where不行

# 数据库多表查询where和inner join
在多表查询时，有些人喜欢用where替代inner join，但是使用where语句，相当于是先做**笛卡尔积**，创建大量数据后在进行过滤，因此使用inner join替代会更好一些

# 主键 超键 候选键
可以说：超键 > 候选键 > 主键
- 超键:在关系中能唯一标识元组的属性集称为关系模式的超键。（身份证，姓名）（身份证）（姓名）
- 候选键是最小超键，即没有多余属性，如（身份证，姓名）就不可，他们任意一个都可以单独确定一行
- 主键是候选键其中选一个

# 数据库三范式
三范式的作用主要是为了防止插入，删除，更新异常

## 第一范式
确保每列保持原子性，如地址这个属性，地址可能包含省份，市区，县，镇等，因此我们需要将地址拆分开，或者如联系人包含电话，姓名，性别等，也需要拆开。这样才可以满足第一范式。因此我们要满足这个是个二维表

## 第二范式
（确保表中每列与主键相关，而不是部分相关）必须有一个主键，没有包含在主键中的列需要完全依赖主键。如(订单ID,商品ID，商品单价，商品名称)，商品单价和商品名称只依赖订单ID

## 第三范式
第三范式：（确保每列和主键列直接相关，而不是间接相关，即不能有传递依赖）如（订单ID，客户ID，客户姓名），订单ID->客户ID->客户姓名

# 数据库为什么用B+树而不用红黑树
- 传统二叉树，如avl,bst,rbtree，会造成深度过大，磁盘IO读写频繁，进而导致查询效率底下，因此采用多叉树结构。假设一个页大小是4k的话，二叉树的节点会远小于4KB，所以数据库索引使用节点大小恰好等于操作系统一页大小的B+树
- 如果只是查询一个数据的话确实是hash比较快，但是数据库经常会查询多条数据，数据量大的话无法一次性从磁盘调入内存，因此每次加载B+树的一个节点。HASH还不够稳定，有可能退化成O(n)，而且无法排序

# 数据库事务
- Atomicity（原子性），事务所有操作要么成功，要么全部失败回滚。原子性并不能保证一致性，多个事务并发执行的时候，满足原子性，但却无法保证一致性。
- Consistency（一致性，最基本，其他三个是为了保证一致性的存在） ， 事务开始前后，数据库完整性约束不被破坏
- Isolation（隔离性），当多个用户并发访问数据库时，如操作同一张表，事务间不会互相干扰
- Durability（持久性），事务一旦提交，数据就永久被改变了